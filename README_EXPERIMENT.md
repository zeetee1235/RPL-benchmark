# RPL vs BRPL Stress Experiment (Cooja, headless)

This repo automates a three-stage stress test to identify the **RPL collapse point** and compare it to BRPL under the same conditions. All simulations run headlessly via `cooja.jar -nogui=<file.csc>`.

## Quick Start

```bash
# Stage 1: N sweep
./run_sweep_stage1.sh

# Stage 2: link-quality sweep (auto-picks two N values from stage 1)
./run_sweep_stage2.sh

# Stage 3: traffic sweep (auto-picks knee condition from stage 2)
./run_sweep_stage3.sh
```

## Simulation Rules (Reproducibility)

* Total duration: **360s** (WARMUP=60s, MEASURE=300s).
* Only the MEASURE window is used for metrics.
* Each run accepts a **seed** so runs are repeatable.
* Logs are parsed from the fixed CSV format emitted by `receiver_root.c`.

## Output Layout

```
results/
  raw/<stage>/<mode>/Nxx_seedY_srX_irZ_siT.{csc,log,csv}
  summary.csv
  thresholds.csv
```

* `raw/...csv` contains only RX CSV lines for the run.
* `summary.csv` contains per-run metrics.
* `thresholds.csv` is auto-generated by `tools/python/find_thresholds.py`.

## Per-run summary columns

`summary.csv` columns:

```
mode,stage,n_senders,seed,success_ratio,interference_ratio,send_interval_s,
rx_count,tx_expected,pdr,avg_delay_ms,p95_delay_ms,dio_count,dao_count,
duration_s,warmup_s,measure_s,log_path,csc_path
```

Notes:
* `dio_count`/`dao_count` are best-effort counts from the full Cooja log.
* Delay values are converted using `CLOCK_SECOND` (default 128).

## Stage Definitions

### Stage 1: N sweep

* Fixed: `SUCCESS_RATIO=1.0`, `INTERFERENCE_RATIO=1.0`, `SEND_INTERVAL_S=10`
* Sweep N: `{5,10,15,20,25,30,40,50}`
* Seeds: `{1,2,3}`
* Modes: `{rpl-classic, brpl}`

### Stage 2: Link-quality sweep

Automatically selects two N values from Stage 1 using **RPL classic** results:

* **Stable N:** largest N where `PDR >= 0.95`
* **Marginal N:** largest N where `0.90 <= PDR < 0.95`
* If no marginal N exists, use the next N above the stable N (or stable N if none).

Sweep parameters:

* `SUCCESS_RATIO ∈ {1.0,0.95,0.9,0.85,0.8,0.75}`
* `INTERFERENCE_RATIO ∈ {1.0,0.95,0.9,0.85}`
* Seeds `{1,2,3}`, Modes `{rpl-classic, brpl}`

### Stage 3: Traffic sweep

Selects a **knee** condition from Stage 2 (RPL classic):

* If any condition has `0.85 <= PDR <= 0.92`, choose the one **closest to 0.90**.
* Otherwise, choose the condition with PDR **closest to 0.90**.

Sweep parameters:

* `SEND_INTERVAL_S ∈ {20,10,5,2}` (decreasing order)
* Seeds `{1,2,3}`, Modes `{rpl-classic, brpl}`

## Collapse-point detection

`tools/python/find_thresholds.py` scans `summary.csv` (aggregated per condition) and emits the first collapse per mode/stage using:

* `PDR < 0.90` **or** `avg_delay_ms > 5000`
* **or** control overhead spike (`DIO+DAO` >= 2× previous condition, when available)

Sweep order:

* Stage 1: N increasing
* Stage 2: success_ratio ↓ then interference_ratio ↓
* Stage 3: send_interval_s ↓

## Running a single experiment

```bash
./run_experiment.sh \
  --mode rpl-classic \
  --stage stage1 \
  --n-senders 20 \
  --seed 1 \
  --success-ratio 1.0 \
  --interference-ratio 1.0 \
  --send-interval 10
```

### Optional environment overrides

* `CONTIKI`: path to Contiki-NG root
* `DURATION_S`, `WARMUP_S`, `MEASURE_S`
* `TX_RANGE`, `INT_RANGE`
* `CLOCK_SECOND`
* `SIM_TIMEOUT_S`

## Notes

* Build Cooja if needed:
  ```bash
  (cd $CONTIKI/tools/cooja && ./gradlew jar)
  ```
